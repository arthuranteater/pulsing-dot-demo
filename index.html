<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pulsing Dot CSS Demo with Mapbox</title>
    <!-- Mapbox GL JS -->
    <link href='https://api.mapbox.com/mapbox-gl-js/v3.0.1/mapbox-gl.css' rel='stylesheet' />
    <script src='https://api.mapbox.com/mapbox-gl-js/v3.0.1/mapbox-gl.js'></script>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #1a1a1a;
            font-family: Arial, sans-serif;
            color: white;
        }

        .demo-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 40px;
            padding: 20px;
        }

        .demo-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        .demo-title {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .pulse-dot {
            position: relative;
            width: 75px;
            height: 75px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .pulse-ring {
            position: absolute;
            border-radius: 50%;
            animation: pulse 2s cubic-bezier(0.455, 0.03, 0.515, 0.955) infinite;
        }

        .pulse-dot-inner {
            position: relative;
            z-index: 2;
            border-radius: 50%;
            border: 2px solid;
        }

        /* Default red dot */
        .pulse-dot-red .pulse-ring {
            background: rgba(219, 55, 19, 0.6);
        }

        .pulse-dot-red .pulse-dot-inner {
            background: #db3713;
            border-color: #edf0f0;
            width: 22px;
            height: 22px;
        }

        /* Green dot for carrier vehicle */
        .pulse-dot-green .pulse-ring {
            background: rgba(84, 199, 116, 0.6);
        }

        .pulse-dot-green .pulse-dot-inner {
            background: #54c774;
            border-color: #54c774;
            width: 22px;
            height: 22px;
        }

        /* Grey dot */
        .pulse-dot-grey .pulse-ring {
            background: rgba(55, 64, 83, 0.6);
        }

        .pulse-dot-grey .pulse-dot-inner {
            background: #374053;
            border-color: #edf0f0;
            width: 22px;
            height: 22px;
        }

        @keyframes pulse {
            0% { 
                transform: scale(0.33); 
                opacity: 1; 
            }
            80%, 100% { 
                transform: scale(1); 
                opacity: 0; 
            }
        }

        /* Alternative animation styles */
        .pulse-dot-smooth .pulse-ring {
            animation: pulse-smooth 2s ease-in-out infinite;
        }

        @keyframes pulse-smooth {
            0% { 
                transform: scale(0.2); 
                opacity: 0.8; 
            }
            50% { 
                transform: scale(0.8); 
                opacity: 0.4; 
            }
            100% { 
                transform: scale(1.2); 
                opacity: 0; 
            }
        }

        .pulse-dot-fast .pulse-ring {
            animation: pulse-fast 1s ease-out infinite;
        }

        @keyframes pulse-fast {
            0% { 
                transform: scale(0.1); 
                opacity: 1; 
            }
            100% { 
                transform: scale(1.5); 
                opacity: 0; 
            }
        }

        .controls {
            margin-top: 20px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }

        button {
            padding: 8px 16px;
            background: #333;
            color: white;
            border: 1px solid #555;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }

        button:hover {
            background: #444;
        }

        button.active {
            background: #54c774;
        }

        .info {
            background: #2a2a2a;
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
            max-width: 600px;
        }

        /* Map styles */
        .map-container {
            width: 100%;
            height: 500px;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            margin: 20px 0;
        }

        #map {
            width: 100%;
            height: 100%;
        }

        /* Map marker styles */
        .map-marker {
            position: relative;
            width: 75px;
            height: 75px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }

        .map-marker .pulse-ring {
            position: absolute;
            border-radius: 50%;
            animation: pulse 2s cubic-bezier(0.455, 0.03, 0.515, 0.955) infinite;
            width: 100%;
            height: 100%;
        }

        .map-marker .pulse-dot-inner {
            position: relative;
            z-index: 2;
            border-radius: 50%;
            border: 2px solid;
        }

        /* Map marker color variants */
        .map-marker-red .pulse-ring {
            background: rgba(219, 55, 19, 0.6);
        }

        .map-marker-red .pulse-dot-inner {
            background: #db3713;
            border-color: #edf0f0;
            width: 22px;
            height: 22px;
        }

        .map-marker-green .pulse-ring {
            background: rgba(84, 199, 116, 0.6);
        }

        .map-marker-green .pulse-dot-inner {
            background: #54c774;
            border-color: #54c774;
            width: 22px;
            height: 22px;
        }

        .map-marker-grey .pulse-ring {
            background: rgba(55, 64, 83, 0.6);
        }

        .map-marker-grey .pulse-dot-inner {
            background: #374053;
            border-color: #edf0f0;
            width: 22px;
            height: 22px;
        }

        .map-section {
            width: 100%;
            max-width: 1000px;
        }

        .map-title {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 10px;
            text-align: center;
        }
    </style>
</head>
<body>
    <div class="demo-container">
        <h1>Pulsing Dot CSS Animation Demo</h1>
        
        <div class="demo-section">
            <div class="demo-title">Default Red Dot</div>
            <div class="pulse-dot pulse-dot-red">
                <div class="pulse-ring"></div>
                <div class="pulse-dot-inner"></div>
            </div>
        </div>

        <div class="demo-section">
            <div class="demo-title">Green Dot (Carrier Vehicle)</div>
            <div class="pulse-dot pulse-dot-green">
                <div class="pulse-ring"></div>
                <div class="pulse-dot-inner"></div>
            </div>
        </div>

        <div class="demo-section">
            <div class="demo-title">Grey Dot</div>
            <div class="pulse-dot pulse-dot-grey">
                <div class="pulse-ring"></div>
                <div class="pulse-dot-inner"></div>
            </div>
        </div>

        <div class="demo-section">
            <div class="demo-title">Animation Variations</div>
            <div style="display: flex; gap: 40px; flex-wrap: wrap; justify-content: center;">
                <div>
                    <div style="text-align: center; margin-bottom: 10px;">Smooth</div>
                    <div class="pulse-dot pulse-dot-red pulse-dot-smooth">
                        <div class="pulse-ring"></div>
                        <div class="pulse-dot-inner"></div>
                    </div>
                </div>
                <div>
                    <div style="text-align: center; margin-bottom: 10px;">Fast</div>
                    <div class="pulse-dot pulse-dot-green pulse-dot-fast">
                        <div class="pulse-ring"></div>
                        <div class="pulse-dot-inner"></div>
                    </div>
                </div>
            </div>
        </div>

        <div class="map-section">
            <div class="map-title">Pulsing Dots on Mapbox Map</div>
            <div class="map-container">
                <div id="map"></div>
            </div>
            <div class="controls">
                <button onclick="switchToPreRenderedMode()" id="btn-prerendered">WebGL Mode (Active)</button>
                <button onclick="switchToLowFrameMode()" id="btn-lowframe">Switch to Low Frame Mode</button>
                <button onclick="switchToCSSMode()" id="btn-css">Switch to CSS Overlay Mode</button>
            </div>
        </div>

        <div class="controls">
            <button onclick="toggleAnimation('red')" id="btn-red">Toggle Red</button>
            <button onclick="toggleAnimation('green')" id="btn-green">Toggle Green</button>
            <button onclick="toggleAnimation('grey')" id="btn-grey">Toggle Grey</button>
        </div>

        <div class="info">
            <h3>Implementation Comparison:</h3>
            
            <h4>🎨 CSS Animations (Demo Section):</h4>
            <ul>
                <li><strong>GPU Accelerated:</strong> CSS animations are handled by the GPU, not the CPU</li>
                <li><strong>No Canvas Redrawing:</strong> No continuous canvas operations at 60fps</li>
                <li><strong>VM Friendly:</strong> Minimal resource usage, perfect for virtual machines</li>
                <li><strong>Smooth Performance:</strong> Hardware-accelerated animations</li>
                <li><strong>Easy Customization:</strong> Simple CSS properties to modify colors, timing, and effects</li>
            </ul>
            
            <h4>🗺️ Mapbox addLayer (Map Implementation):</h4>
            <ul>
                <li><strong>Native Integration:</strong> Uses Mapbox's native rendering engine</li>
                <li><strong>Scalable Performance:</strong> Can handle thousands of pulsing dots efficiently</li>
                <li><strong>Data-Driven Styling:</strong> Dynamic styling based on GeoJSON properties</li>
                <li><strong>Zoom Responsive:</strong> Automatically scales with map zoom level</li>
                <li><strong>Interactive Features:</strong> Easy to add click handlers, popups, and interactions</li>
                <li><strong>Memory Efficient:</strong> No DOM elements, pure GPU rendering</li>
            </ul>
            
            <h3>Key Implementation Details:</h3>
            <ul>
                <li><strong>CSS Method:</strong> <code>animation: pulse 2s cubic-bezier(0.455, 0.03, 0.515, 0.955) infinite;</code></li>
                <li><strong>Mapbox Method:</strong> <code>requestAnimationFrame</code> with <code>setPaintProperty()</code></li>
                <li><strong>Scale Animation:</strong> <code>transform: scale(0.33)</code> to <code>scale(1.0)</code></li>
                <li><strong>Opacity Fade:</strong> <code>opacity: 1</code> to <code>opacity: 0</code></li>
                <li><strong>Duration:</strong> 2 seconds with smooth easing curves</li>
            </ul>
            
            <h3>Performance Benefits:</h3>
            <ul>
                <li><strong>CSS Animations:</strong> Best for static demos and UI elements</li>
                <li><strong>Mapbox Layers:</strong> Best for map-based applications with many markers</li>
                <li><strong>Hybrid Approach:</strong> Use CSS for demos, Mapbox layers for production maps</li>
            </ul>
        </div>
    </div>

    <script>
        // Global variables
        let map;
        let markers = {
            red: [],
            green: [],
            grey: []
        };

        // Initialize Mapbox map
        function initMap() {
            // You'll need to replace 'YOUR_MAPBOX_ACCESS_TOKEN' with your actual Mapbox access token
            mapboxgl.accessToken = 'pk.eyJ1IjoiaHVudGFwcGxlZ2F0ZSIsImEiOiJjbWc5bjA5bmgwYWY0MmtvdW12eWo5cjZzIn0.bFFqd6EHoa2F-CPvvKz8WQ'; // Replace with your token
            
            map = new mapboxgl.Map({
                container: 'map',
                style: 'mapbox://styles/mapbox/dark-v11', // Dark theme to match the demo
                center: [-74.5, 40], // New York area
                zoom: 9
            });

            // Wait for map to load before adding layers
            map.on('load', function() {
                setupPulsingDots();
            });
        }

        // Import the pre-rendered pulsing dot function (most GPU-efficient)
        function createPreRenderedPulsingDot(isCarrierVehicleOnRoute = false, isGrey = false) {
            const size = 75;
            const frameCount = 20; // 20 frames for smooth animation
            let currentFrame = 0;
            let lastUpdate = 0;
            const frameInterval = 100; // 100ms per frame
            
            const colors = isGrey 
                ? { outer: 'rgba(55, 64, 83, 0.6)', inner: 'rgba(55, 64, 83, 1)', stroke: 'rgba(237, 240, 240, 0.7)' }
                : isCarrierVehicleOnRoute 
                    ? { outer: 'rgba(84, 199, 116, 0.6)', inner: 'rgba(84, 199, 116, 1)', stroke: 'rgba(84, 199, 116, 1)' }
                    : { outer: 'rgba(219, 55, 19, 0.6)', inner: 'rgba(219, 55, 19, 1)', stroke: 'rgba(237, 240, 240, 0.7)' };

            return {
                size: size,
                width: size,
                height: size,
                data: new Uint8Array(size * size * 4),
                isCarrierVehicleOnRoute: isCarrierVehicleOnRoute,
                isGrey: isGrey,
                stopPulse: false,
                preRenderedFrames: null,

                onAdd: function () {
                    const canvas = document.createElement('canvas');
                    canvas.width = this.width;
                    canvas.height = this.height;
                    this.context = canvas.getContext('2d', { willReadFrequently: true });
                    
                    // Pre-render all animation frames
                    this.preRenderedFrames = [];
                    for (let i = 0; i < frameCount; i++) {
                        const t = i / frameCount;
                        const radius = (this.size / 2) * 0.3;
                        const outerRadius = (this.size / 2) * 0.7 * t + radius;
                        
                        this.context.clearRect(0, 0, this.width, this.height);
                        this.context.beginPath();
                        this.context.arc(this.width / 2, this.height / 2, outerRadius, 0, Math.PI * 2);
                        this.context.fillStyle = colors.outer.replace('0.6', (0.6 - t).toFixed(2));
                        this.context.fill();
                        
                        this.context.beginPath();
                        this.context.arc(this.width / 2, this.height / 2, radius, 0, Math.PI * 2);
                        this.context.fillStyle = colors.inner;
                        this.context.strokeStyle = colors.stroke;
                        this.context.lineWidth = 2;
                        this.context.fill();
                        this.context.stroke();
                        
                        this.preRenderedFrames.push(
                            this.context.getImageData(0, 0, this.width, this.height).data.slice()
                        );
                    }
                },

                render: function () {
                    const now = performance.now();
                    if (now - lastUpdate < frameInterval) {
                        return false;
                    }
                    lastUpdate = now;

                    if (this.preRenderedFrames && this.preRenderedFrames.length > 0) {
                        this.data = this.preRenderedFrames[currentFrame];
                        currentFrame = (currentFrame + 1) % this.preRenderedFrames.length;
                        return true;
                    }
                    return false;
                },
            };
        }

        // Keep the low frame rate function as backup
        function createLowFrameRatePulsingDot(isCarrierVehicleOnRoute = false, isGrey = false) {
            const size = 75;
            let lastUpdate = 0;
            const updateInterval = 100; // Update every 100ms instead of every frame
            
            return {
                size: size,
                width: size,
                height: size,
                data: new Uint8Array(size * size * 4),
                isCarrierVehicleOnRoute: isCarrierVehicleOnRoute,
                isGrey: isGrey,
                stopPulse: false,

                onAdd: function () {
                    const canvas = document.createElement('canvas');
                    canvas.width = this.width;
                    canvas.height = this.height;
                    this.context = canvas.getContext('2d', { willReadFrequently: true });
                },

                render: function () {
                    const now = performance.now();
                    if (now - lastUpdate < updateInterval) {
                        return false; // Skip this frame
                    }
                    lastUpdate = now;

                    const duration = 2000;
                    const t = (performance.now() % duration) / duration;

                    const radius = (this.size / 2) * 0.3;
                    const outerRadius = (this.size / 2) * 0.7 * t + radius;
                    const context = this.context;

                    // Draw the outer circle.
                    context.clearRect(0, 0, this.width, this.height);
                    context.beginPath();
                    context.arc(
                        this.width / 2,
                        this.height / 2,
                        outerRadius,
                        0,
                        Math.PI * 2
                    );
                    
                    const colors = this.isGrey 
                        ? { outer: 'rgba(55, 64, 83, 0.6)', inner: 'rgba(55, 64, 83, 1)', stroke: 'rgba(237, 240, 240, 0.7)' }
                        : this.isCarrierVehicleOnRoute 
                            ? { outer: 'rgba(84, 199, 116, 0.6)', inner: 'rgba(84, 199, 116, 1)', stroke: 'rgba(84, 199, 116, 1)' }
                            : { outer: 'rgba(219, 55, 19, 0.6)', inner: 'rgba(219, 55, 19, 1)', stroke: 'rgba(237, 240, 240, 0.7)' };

                    context.fillStyle = this.stopPulse
                        ? `rgba(219, 55, 19, 0)`
                        : colors.outer.replace('0.6', (0.6 - t).toFixed(2));
                    context.fill();

                    // Draw the inner circle.
                    context.beginPath();
                    context.arc(this.width / 2, this.height / 2, radius, 0, Math.PI * 2);
                    context.fillStyle = colors.inner;
                    context.strokeStyle = colors.stroke;
                    context.lineWidth = 2;
                    context.fill();
                    context.stroke();

                    // Update this image's data with data from the canvas.
                    this.data = context.getImageData(0, 0, this.width, this.height).data;

                    return true;
                },
            };
        }

        // Setup pulsing dots using Custom WebGL Layer
        function setupPulsingDots() {
            console.log('Setting up Custom WebGL pulsing dots...');
            
            // Add source for pulsing dots
            map.addSource('dot-point', {
                type: 'geojson',
                data: {
                    type: 'FeatureCollection',
                    features: [
                        {
                            type: 'Feature',
                            properties: {
                                color: 'red',
                                id: 0
                            },
                            geometry: {
                                type: 'Point',
                                coordinates: [-74.5, 40]
                            }
                        },
                        {
                            type: 'Feature',
                            properties: {
                                color: 'green',
                                id: 1
                            },
                            geometry: {
                                type: 'Point',
                                coordinates: [-74.3, 40.1]
                            }
                        },
                        {
                            type: 'Feature',
                            properties: {
                                color: 'grey',
                                id: 2
                            },
                            geometry: {
                                type: 'Point',
                                coordinates: [-74.7, 39.9]
                            }
                        }
                    ]
                }
            });

            // Add Custom WebGL Layer
            map.addLayer({
                id: 'pulsing-webgl',
                type: 'custom',
                source: 'dot-point',
                onAdd: function(map, gl) {
                    // Vertex shader
                    const vertexShader = `
                        attribute vec2 a_pos;
                        attribute float a_color;
                        attribute float a_id;
                        
                        uniform mat4 u_matrix;
                        uniform float u_time;
                        uniform float u_zoom;
                        
                        varying float v_color;
                        varying float v_id;
                        varying float v_pulse;
                        
                        void main() {
                            v_color = a_color;
                            v_id = a_id;
                            
                            // Calculate pulse animation
                            float t = mod(u_time * 0.5, 1.0);
                            v_pulse = sin(t * 3.14159);
                            
                            gl_Position = u_matrix * vec4(a_pos, 0.0, 1.0);
                        }
                    `;
                    
                    // Fragment shader
                    const fragmentShader = `
                        precision mediump float;
                        
                        uniform float u_time;
                        uniform float u_zoom;
                        
                        varying float v_color;
                        varying float v_id;
                        varying float v_pulse;
                        
                        void main() {
                            vec2 center = gl_FragCoord.xy;
                            vec2 pos = gl_FragCoord.xy;
                            
                            // Calculate distance from center
                            float dist = distance(pos, center);
                            
                            // Base dot radius
                            float baseRadius = 8.0;
                            
                            // Pulsing ring
                            float pulseRadius = baseRadius + (v_pulse * 20.0);
                            float pulseOpacity = (1.0 - v_pulse) * 0.6;
                            
                            // Color based on v_color
                            vec3 color;
                            if (v_color < 0.5) {
                                color = vec3(0.85, 0.22, 0.08); // Red
                            } else if (v_color < 1.5) {
                                color = vec3(0.33, 0.78, 0.45); // Green
                            } else {
                                color = vec3(0.22, 0.25, 0.33); // Grey
                            }
                            
                            // Draw base dot
                            if (dist < baseRadius) {
                                gl_FragColor = vec4(color, 1.0);
                            }
                            // Draw pulsing ring
                            else if (dist < pulseRadius) {
                                float ringOpacity = pulseOpacity * (1.0 - (dist - baseRadius) / (pulseRadius - baseRadius));
                                gl_FragColor = vec4(color, ringOpacity);
                            }
                            else {
                                discard;
                            }
                        }
                    `;
                    
                    // Create shader program
                    const vertexShaderObj = gl.createShader(gl.VERTEX_SHADER);
                    gl.shaderSource(vertexShaderObj, vertexShader);
                    gl.compileShader(vertexShaderObj);
                    
                    const fragmentShaderObj = gl.createShader(gl.FRAGMENT_SHADER);
                    gl.shaderSource(fragmentShaderObj, fragmentShader);
                    gl.compileShader(fragmentShaderObj);
                    
                    this.program = gl.createProgram();
                    gl.attachShader(this.program, vertexShaderObj);
                    gl.attachShader(this.program, fragmentShaderObj);
                    gl.linkProgram(this.program);
                    
                    // Get attribute and uniform locations
                    this.a_pos = gl.getAttribLocation(this.program, 'a_pos');
                    this.a_color = gl.getAttribLocation(this.program, 'a_color');
                    this.a_id = gl.getAttribLocation(this.program, 'a_id');
                    this.u_matrix = gl.getUniformLocation(this.program, 'u_matrix');
                    this.u_time = gl.getUniformLocation(this.program, 'u_time');
                    this.u_zoom = gl.getUniformLocation(this.program, 'u_zoom');
                    
                    // Create buffer for positions
                    this.buffer = gl.createBuffer();
                },
                
                render: function(gl, matrix) {
                    gl.useProgram(this.program);
                    
                    // Set uniforms
                    gl.uniformMatrix4fv(this.u_matrix, false, matrix);
                    gl.uniform1f(this.u_time, performance.now() / 1000.0);
                    gl.uniform1f(this.u_zoom, map.getZoom());
                    
                    // Get source data
                    const source = map.getSource('dot-point');
                    const data = source._data;
                    
                    if (data && data.features) {
                        // Prepare vertex data
                        const positions = [];
                        const colors = [];
                        const ids = [];
                        
                        data.features.forEach(feature => {
                            const coords = feature.geometry.coordinates;
                            const color = feature.properties.color;
                            const id = feature.properties.id;
                            
                            // Convert to screen coordinates
                            const point = map.project([coords[0], coords[1]]);
                            
                            positions.push(point.x, point.y);
                            
                            // Color mapping
                            let colorValue;
                            if (color === 'red') colorValue = 0.0;
                            else if (color === 'green') colorValue = 1.0;
                            else colorValue = 2.0;
                            
                            colors.push(colorValue);
                            ids.push(id);
                        });
                        
                        // Upload data to GPU
                        gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
                        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
                        
                        // Set up attributes
                        gl.enableVertexAttribArray(this.a_pos);
                        gl.vertexAttribPointer(this.a_pos, 2, gl.FLOAT, false, 0, 0);
                        
                        // Draw points
                        gl.drawArrays(gl.POINTS, 0, positions.length / 2);
                    }
                }
            });
            
            console.log('Custom WebGL pulsing dots created');
        }

        // WebGL shader handles animation directly - no JavaScript animation needed

        // Animation is now handled by the imported function - no additional animation needed

        // Alternative: Use CSS animations on a single overlay layer (most efficient)
        function createCSSPulsingOverlay() {
            // Remove existing layers
            if (map.getLayer('pulsing-rings')) map.removeLayer('pulsing-rings');
            if (map.getLayer('pulsing-dots-inner')) map.removeLayer('pulsing-dots-inner');
            
            // Create a single overlay with CSS animations
            const overlay = document.createElement('div');
            overlay.id = 'pulsing-overlay';
            overlay.style.position = 'absolute';
            overlay.style.pointerEvents = 'none';
            overlay.style.zIndex = '1000';
            
            // Add CSS for pulsing animation
            const style = document.createElement('style');
            style.textContent = `
                .pulsing-overlay-dot {
                    position: absolute;
                    width: 40px;
                    height: 40px;
                    border-radius: 50%;
                    transform: translate(-50%, -50%);
                    pointer-events: none;
                }
                .pulsing-overlay-dot::before {
                    content: '';
                    position: absolute;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    border-radius: 50%;
                    animation: pulse-overlay 2s infinite;
                }
                @keyframes pulse-overlay {
                    0% { transform: scale(0.33); opacity: 1; }
                    80%, 100% { transform: scale(1); opacity: 0; }
                }
            `;
            document.head.appendChild(style);
            
            // Add dots to overlay
            const dots = [
                { color: '#db3713', lng: -74.5, lat: 40 },
                { color: '#54c774', lng: -74.3, lat: 40.1 },
                { color: '#374053', lng: -74.7, lat: 39.9 }
            ];
            
            dots.forEach(dot => {
                const dotEl = document.createElement('div');
                dotEl.className = 'pulsing-overlay-dot';
                dotEl.style.backgroundColor = dot.color;
                dotEl.style.border = '2px solid #edf0f0';
                overlay.appendChild(dotEl);
                
                // Position using map projection
                const pos = map.project([dot.lng, dot.lat]);
                dotEl.style.left = pos.x + 'px';
                dotEl.style.top = pos.y + 'px';
            });
            
            // Add overlay to map container
            map.getContainer().appendChild(overlay);
            
            // Update positions on map move
            map.on('move', updateOverlayPositions);
            map.on('zoom', updateOverlayPositions);
        }
        
        function updateOverlayPositions() {
            const overlay = document.getElementById('pulsing-overlay');
            if (!overlay) return;
            
            const dots = [
                { lng: -74.5, lat: 40 },
                { lng: -74.3, lat: 40.1 },
                { lng: -74.7, lat: 39.9 }
            ];
            
            const dotElements = overlay.querySelectorAll('.pulsing-overlay-dot');
            dots.forEach((dot, index) => {
                if (dotElements[index]) {
                    const pos = map.project([dot.lng, dot.lat]);
                    dotElements[index].style.left = pos.x + 'px';
                    dotElements[index].style.top = pos.y + 'px';
                }
            });
        }

        // Stop the pulsing animation
        function stopPulsingAnimation() {
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
        }

        // Switch to WebGL mode (most efficient)
        function switchToPreRenderedMode() {
            // Clear existing layers and sources
            if (map.getLayer('pulsing-webgl')) map.removeLayer('pulsing-webgl');
            if (map.getLayer('base-dot')) map.removeLayer('base-dot');
            if (map.getLayer('pulsing-circle')) map.removeLayer('pulsing-circle');
            if (map.getSource('dot-point')) map.removeSource('dot-point');
            
            // Remove CSS overlay if it exists
            const overlay = document.getElementById('pulsing-overlay');
            if (overlay) overlay.remove();
            
            // Recreate with WebGL layers
            setupPulsingDots();
            
            document.getElementById('btn-prerendered').textContent = 'WebGL Mode (Active)';
            document.getElementById('btn-lowframe').textContent = 'Switch to Low Frame Mode';
            document.getElementById('btn-css').textContent = 'Switch to CSS Overlay Mode';
        }

        // Switch to low frame rate mode (using markers)
        function switchToLowFrameMode() {
            // Stop any existing animation
            stopPulseAnimation();
            
            // Clear existing layers and sources
            if (map.getLayer('base-dot')) map.removeLayer('base-dot');
            if (map.getLayer('pulsing-circle')) map.removeLayer('pulsing-circle');
            if (map.getSource('dot-point')) map.removeSource('dot-point');
            
            // Remove CSS overlay if it exists
            const overlay = document.getElementById('pulsing-overlay');
            if (overlay) overlay.remove();
            
            // Create markers with low frame rate function
            console.log('Setting up low frame rate pulsing dots...');
            
            const redDot = createLowFrameRatePulsingDot(false, false);
            const greenDot = createLowFrameRatePulsingDot(true, false);
            const greyDot = createLowFrameRatePulsingDot(false, true);
            
            const redMarker = new mapboxgl.Marker(redDot).setLngLat([-74.5, 40]).addTo(map);
            const greenMarker = new mapboxgl.Marker(greenDot).setLngLat([-74.3, 40.1]).addTo(map);
            const greyMarker = new mapboxgl.Marker(greyDot).setLngLat([-74.7, 39.9]).addTo(map);
            
            markers.red = [redMarker];
            markers.green = [greenMarker];
            markers.grey = [greyMarker];
            
            document.getElementById('btn-lowframe').textContent = 'Low Frame Mode (Active)';
            document.getElementById('btn-prerendered').textContent = 'Switch to Data-Driven Mode';
            document.getElementById('btn-css').textContent = 'Switch to CSS Overlay Mode';
        }

        // Switch to CSS overlay mode (most efficient)
        function switchToCSSMode() {
            // Stop any existing animation
            stopPulseAnimation();
            
            // Clear existing layers and sources
            if (map.getLayer('base-dot')) map.removeLayer('base-dot');
            if (map.getLayer('pulsing-circle')) map.removeLayer('pulsing-circle');
            if (map.getSource('dot-point')) map.removeSource('dot-point');
            
            // Clear existing markers
            Object.values(markers).flat().forEach(marker => marker.remove());
            markers.red = [];
            markers.green = [];
            markers.grey = [];
            
            // Create CSS overlay
            createCSSPulsingOverlay();
            
            document.getElementById('btn-css').textContent = 'CSS Overlay Mode (Active)';
            document.getElementById('btn-prerendered').textContent = 'Switch to Data-Driven Mode';
            document.getElementById('btn-lowframe').textContent = 'Switch to Low Frame Mode';
        }

        // Legacy marker functions (kept for compatibility but not used in layer-based approach)
        // These are now replaced by the addLayer implementation above

        // Removed toggle and add marker functions - not needed for demo

        // Original toggle animation function
        function toggleAnimation(color) {
            const dots = document.querySelectorAll(`.pulse-dot-${color}`);
            const button = document.getElementById(`btn-${color}`);
            
            dots.forEach(dot => {
                const ring = dot.querySelector('.pulse-ring');
                if (ring.style.animationPlayState === 'paused') {
                    ring.style.animationPlayState = 'running';
                    button.textContent = `Pause ${color.charAt(0).toUpperCase() + color.slice(1)}`;
                    button.classList.add('active');
                } else {
                    ring.style.animationPlayState = 'paused';
                    button.textContent = `Resume ${color.charAt(0).toUpperCase() + color.slice(1)}`;
                    button.classList.remove('active');
                }
            });
        }

        // Debug function to test animation
        function testAnimation() {
            console.log('Testing animation...');
            const testDiv = document.createElement('div');
            testDiv.style.position = 'fixed';
            testDiv.style.top = '10px';
            testDiv.style.left = '10px';
            testDiv.style.zIndex = '9999';
            testDiv.innerHTML = `
                <div class="pulse-dot pulse-dot-red">
                    <div class="pulse-ring"></div>
                    <div class="pulse-dot-inner"></div>
                </div>
            `;
            document.body.appendChild(testDiv);
            
            setTimeout(() => {
                document.body.removeChild(testDiv);
            }, 5000);
        }

        // Initialize everything when DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize button text for demo controls
            document.getElementById('btn-red').textContent = 'Pause Red';
            document.getElementById('btn-green').textContent = 'Pause Green';
            document.getElementById('btn-grey').textContent = 'Pause Grey';
            
            // Initialize map
            initMap();
            
            // Test animation after a short delay
            setTimeout(testAnimation, 1000);
            
            // No fallback needed - using proper image-based layers
        });

        // Using proper image-based layers - no fallbacks needed
    </script>
</body>
</html>
<!-- Updated Thu Oct  2 10:56:16 CST 2025 -->
